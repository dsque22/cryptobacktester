# Project Overview: Crypto Trading Strategy Backtester v1.0

**Note:** This document has been updated to reflect the latest version of the codebase, which focuses on a single, powerful strategy (HMA+WAE) and provides more detailed backtesting results.

This document provides a comprehensive overview of the Crypto Trading Strategy Backtester, analyzed from the perspectives of a Software Architect, a Software Developer, and a Product Manager.

---

## 1. Software Architect Perspective

From an architectural standpoint, the system is designed as a modular, extensible framework for backtesting cryptocurrency trading strategies. The core principles are separation of concerns, flexibility, and ease of use.

### 1.1. System Architecture

The application is broken down into five main components, each with a distinct responsibility. This modular design makes the system easier to understand, maintain, and extend.

```mermaid
graph TD
    A[main.py] --> B(Data Fetcher);
    A --> C(Data Processor);
    A --> D(Strategy);
    A --> E(Backtesting Engine);
    E --> F(Performance Metrics);
    E --> G(Visualization);
    F --> H[CSV Reports];

    subgraph "Data Pipeline"
        B; C;
    end

    subgraph "Strategy Execution"
        D; E;
    end

    subgraph "Results & Analysis"
        F; G; H;
    end

    style A fill:#f9f,stroke:#333,stroke-width:2px
```

**Component Responsibilities:**

*   **`main.py` (Orchestrator):** The entry point of the application. It has been refactored to focus on running a single, highly configurable strategy (`HMA_WAE`). It coordinates the actions of all other components, from fetching data for a specific symbol and timeframe to running the backtest and generating reports.
*   **Data Fetcher (`src/data/data_fetcher.py`):** Responsible for acquiring historical price data. It includes a fallback mechanism (Yahoo Finance -> Binance) and a caching layer to improve performance and reduce external API calls.
*   **Data Processor (`src/data/data_processor.py`):** Cleans the raw data and enriches it with technical indicators and return calculations, preparing it for the strategies.
*   **Strategy (`src/strategy/`):** Implements the trading logic. A `BaseStrategy` abstract class defines a common interface, and concrete strategies (e.g., `SMAStrategy`, `RSIStrategy`) provide the specific rules for generating buy/sell signals. This is a classic example of the **Strategy Design Pattern**.
*   **Backtesting Engine (`src/backtesting/engine.py`):** The core of the application. It simulates the execution of trades based on the signals generated by a strategy, accounting for factors like commission and slippage. Individual trades are stored as `Trade` dataclass objects.
*   **Performance Metrics (`src/backtesting/metrics.py`):** Calculates a wide range of metrics (e.g., Sharpe ratio, Sortino Ratio, Calmar Ratio, max drawdown) to evaluate the performance of a strategy. The results are encapsulated in a `BacktestResults` dataclass and can be exported to detailed CSV files for both performance summaries and individual trade logs.
*   **Visualization (`src/visualization/charts.py`):** Generates visual reports, including equity curves, and saves them as image files in the `results` directory.

### 1.2. Data Pipeline

The data pipeline is designed to be robust and efficient.

```mermaid
flowchart LR
    A[Fetch Request] --> B{Cache Check};
    B -- Hit --> C[Load from Parquet];
    B -- Miss --> D{Fetch from Binance};
    D -- Success --> E[Save to Cache];
    D -- Failure --> F{Fetch from Yahoo Finance};
    F -- Success --> E;
    F -- Failure --> G[Error];
    C --> H(Data Processor);
    E --> H;
```

*   **Data Sources:** The primary data source is Binance, with Yahoo Finance used as a fallback, providing redundancy.
*   **Caching:** Successfully fetched data is stored in the `data/cache` directory as Parquet files. This is a highly efficient columnar storage format that significantly speeds up subsequent data loading. The cache has a configurable expiry time.
*   **Processing:** The `DataProcessor` cleans the data (handles NaNs, validates prices) and then calculates a standard set of technical indicators and returns. This pre-calculation saves computation time during the backtest.

### 1.3. Backtesting Engine Design

The engine follows a simple, vectorized event-driven model. It iterates through each timestamp in the dataset and processes the trading signal for that point in time.

```mermaid
graph TD
    A(Start Backtest) --> B{For each Timestamp};
    B --> C{Get Signal from pre-computed Series};
    C -- Buy/Sell (1 or -1) --> D{Position Open?};
    D -- No --> E[Open Position];
    D -- Yes --> F{Is Signal a Reversal? (e.g. from 1 to -1)};
    F -- Yes --> G[Close Position];
    G --> E;
    F -- No --> H[Hold Position];
    C -- Close/Hold (0) --> I{Position Open?};
    I -- Yes --> J[Close Position];
    I -- No --> H[Hold Position];
    J --> B;
    E --> B;
    H --> B;
    B -- End of Data --> K(Generate Final Results & Reports);
```

*   **State Management:** The `Backtester` class maintains the state of the portfolio at all times, including capital, current position (long, short, or flat), and trade history. Each trade is recorded in a `Trade` object, capturing details like entry/exit times, prices, and P&L.
*   **Trade Execution:** The engine simulates trades by opening and closing positions based on the signals. It incorporates slippage and commission to provide more realistic results.
*   **Position Sizing:** A fixed fractional position sizing strategy is used (35% of available capital per trade). This is a simple approach to money management.
*   **Assumptions & Limitations:**
    *   **Market Orders:** The engine assumes all trades are executed as market orders at the closing price of the bar.
    *   **Fixed Slippage/Commission:** These are modeled as fixed percentages, which may not reflect real market conditions accurately.
    *   **No Partial Fills:** The engine assumes all orders are filled completely.

---

## 2. Software Developer Perspective

This section provides practical information for developers working with the codebase.

### 2.1. Getting Started

1.  **Clone the repository:**
    ```bash
    git clone <your-repo-url>
    cd crypto_backtester
    ```

2.  **Install dependencies:**
    ```bash
    pip install -r requirements.txt
    ```

3.  **Run the main script:**
    ```bash
    python main.py
    ```
    This will run a backtest for the HMA+WAE strategy on `BTC-USD` using an 8-hour timeframe by default. The configuration (Symbol, Timeframe) can be easily changed within `main.py`. Results are saved in the `results` folder.

### 2.2. Project Structure

```
.
â”œâ”€â”€ config.py           # Configuration settings
â”œâ”€â”€ data/               # Data and cache files
â”œâ”€â”€ main.py             # Main entry point
â”œâ”€â”€ README.md
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ results/            # Saved charts and reports
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ backtesting/    # Backtesting engine and metrics
â”‚   â”œâ”€â”€ data/           # Data fetching and processing
â”‚   â”œâ”€â”€ strategy/       # Base strategy and implementations
â”‚   â””â”€â”€ visualization/  # Charting and reporting
â””â”€â”€ utils.py            # Utility functions
```

### 2.3. How to Add a New Strategy

Creating a new trading strategy is straightforward:

1.  **Create a new class** in `src/strategy/strategies.py` that inherits from `BaseStrategy`.
2.  **Implement the `generate_signals` method.** This method takes a pandas DataFrame (with OHLCV and indicators) as input and must return a pandas Series of signals (`1` for buy, `-1` for sell, `0` for hold).
3.  **Add a convenience function** in `strategies.py` to create an instance of your new strategy.
4.  **Integrate it** into `main.py` by replacing the existing strategy.

**Example: A Simple "Buy and Hold" Strategy**

```python
# In src/strategy/strategies.py, add the new class and function:

class BuyAndHoldStrategy(BaseStrategy):
    """A simple buy and hold strategy."""
    
    def __init__(self):
        super().__init__("BuyAndHold")
        
    def generate_signals(self, data: pd.DataFrame) -> pd.Series:
        """Buy on the first day and hold."""
        signals = pd.Series(0, index=data.index, dtype=float)
        signals.iloc[0] = 1.0  # Buy signal on the first bar
        return signals

def create_buy_and_hold_strategy() -> BuyAndHoldStrategy:
    """Creates a Buy and Hold Strategy instance."""
    return BuyAndHoldStrategy()

# In main.py, update the strategy creation part:

# Import the new function at the top
from src.strategy import create_buy_and_hold_strategy

# ... later in the main() function ...

# 3. Create the new strategy
print("\nðŸŽ¯ Creating Buy and Hold strategy...")
strategy = create_buy_and_hold_strategy()

# The rest of the script runs the backtest for this strategy
```

### 2.4. Key Libraries and Tools

*   **`pandas`:** The backbone of the application for data manipulation and analysis.
*   **`yfinance` & `requests`:** Used for fetching data from external APIs.
*   **`ta`:** A comprehensive library for calculating technical analysis indicators.
*   **`matplotlib` & `seaborn`:** Used for creating high-quality visualizations.
*   **`logging`:** Used for providing informative output during the execution of the backtest.

---

## 3. Product Manager Perspective

This section focuses on the product aspects of the backtester.

### 3.1. Product Vision

**What is it?** A lightweight, easy-to-use framework for retail traders and quantitative analysts to rapidly test and validate their trading ideas on historical cryptocurrency data.

**Who is it for?**
*   Traders who want to move from discretionary trading to a more systematic approach.
*   Developers and data scientists interested in algorithmic trading.
*   Students learning about financial markets.

**What problem does it solve?** It lowers the barrier to entry for algorithmic trading by providing a simple but complete backtesting solution, removing the need to build a backtesting system from scratch.

### 3.2. Key Features & User Stories

*   **Feature: Multi-Strategy Backtesting**
    *   *As a user, I want to test multiple strategies at once so that I can compare their performance side-by-side.*
*   **Feature: Comprehensive Performance Metrics**
    *   *As a trader, I need to see detailed metrics like Sharpe Ratio, Sortino Ratio, and Max Drawdown to properly assess the risk and return of my strategy.*
*   **Feature: Visual Performance Reports**
    *   *As a user, I want to see an equity curve chart so I can visually understand how my strategy's value changes over time.*
*   **Feature: Detailed Trade Log Export**
    *   *As a trader, I want to export a log of all simulated trades so I can analyze the individual decisions of the strategy.*
*   **Feature: Comprehensive Performance Report Export**
    *   *As an analyst, I want a CSV report of all performance metrics so I can do my own offline analysis and comparisons.*
*   **Feature: Configurable Timeframes**
    *   *As a user, I want to easily change the timeframe of the backtest to see how my strategy performs on different chart resolutions.*
*   **Feature: Extensible Strategy Framework**
    *   *As a developer, I want a simple way to add my own custom strategies so I can test my unique trading ideas.*
*   **Feature: Data Caching**
    *   *As a user, I want the application to run quickly on subsequent launches so I can iterate on my ideas faster.*

### 3.3. Current Strategies

The backtester comes with four pre-built strategies defined in `src/strategy/strategies.py`. While the main script currently focuses on `HMA + WAE`, any of the other strategies can be easily swapped in.
1.  **SMA Crossover:** A classic trend-following strategy that buys when a fast-moving average crosses above a slow one.
2.  **RSI Mean Reversion:** A strategy that buys when an asset is "oversold" and sells when it's "overbought," based on the RSI indicator.
3.  **Bollinger Bands:** Another mean-reversion strategy that trades based on the price touching the upper or lower bands.
4.  **HMA + WAE:** A more advanced strategy that uses a fast-reacting moving average (HMA) and a momentum filter to find entry points.

### 3.4. Potential Future Enhancements

The current framework provides a solid foundation that can be extended with many new features:

*   **Parameter Optimization:** Add functionality to automatically test a range of strategy parameters (e.g., different SMA periods) to find the optimal settings.
*   **Walk-Forward Analysis:** Implement a more robust testing method that simulates how a strategy would perform in real-time.
*   **Support for More Assets:** Extend the data fetcher to support other asset classes like stocks, forex, or futures.
*   **Advanced Risk Management:**
    *   Implement stop-loss and take-profit orders.
    *   Introduce more dynamic position sizing models (e.g., based on volatility).
*   **Portfolio-Level Backtesting:** Allow testing of strategies across a portfolio of multiple assets simultaneously.
*   **Web-Based User Interface:** Create a simple web app (using Flask or Streamlit) to allow users to run backtests and view results without interacting with the code directly.
*   **Re-enabling Multi-Strategy Runner**: Refactor `main.py` to easily run and compare all available strategies, similar to its original design. 
